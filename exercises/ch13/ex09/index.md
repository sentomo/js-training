# i1
## 予想
実行直後に0が出力され、2秒後に42が出力される。

## 結果
1秒後に42が出力され、さらに2秒後に100が出力される。

## 理由
* Promise.any は与えられた複数のPromiseのうち、最初に「成功した」Promiseの結果を返す。すべてのPromiseが失敗した場合は、エラーを投げる。
* 処理順序
  * await Promise.anyの中で一番早く解決するのはwait1()であり、その後のthenで42の値を返している。よって、vに42が代入される。
  * 1回目のlog(v)が実行され、この時点のvは42であるため、42が出力される。
  * await wait2()が実行され、2秒待つ間にPromise.anyのwait2で2秒経って、v=100が実行される。
  * 2回目のlog(v)の時はvが100であるため、100が出力される。

# i2
## 予想
1秒後にC、さらに1秒後にB、さらに1秒後にAと[ 'A', 'B', 'C' ]が2つ出力される。

## 結果
1秒後にC、さらに1秒後にB、さらに1秒後にAと[ 'A', 'B', 'C' ]が出力された。

## 理由
* Promise.all()関数は、非同期処理を並行処理したい時に使う。全てのPromiseが満たされた場合、各Promiseを満たした値の配列で、返されたPromiseが満たされる。配列の要素の順番は、渡されたPromiseの順番である。
* 処理順序
  * Promise.all()の中でwait1が最初に解決されて、logCが実行されてCが出力される。
  * 次にwait2が解決されて、logBが実行されてBが出力される。
  * その次にwait3が解決されて、logAが実行されてAが出力される。
  * Promise.all()の全てのPromiseが満たされたので、渡されたPromiseの順番にそれぞれのPromiseで返された値が[ 'A', 'B', 'C' ]として配列で返し、vに代入される。
  * log(v)が実行され、vとして[ 'A', 'B', 'C' ]が出力される。

# i3
## 予想
1秒後にY、42が出力され、さらに3秒後に42が出力される。

## 結果
1秒後にY、42が出力され、さらに1秒後にBが出力され、さらに2秒後に0が出力された。

## 理由
* Promise.allは、渡されたPromiseのうち1つが拒否されると、その時点で全体が拒否される。他のPromiseはバックグラウンドで継続して処理されている。
* 処理順序
  * Promise.allの中でwait1が1秒後に最初に解決されて、errYが実行されてPromise.allがrejectされてcatchブロックに移動する。
  * catchブロックのlog(e.message)でerrYのYが出力される。
  * catchブロックの1つ目のlog(v)の時点ではvは初期値の42であるため、42が出力される。
  * Promise.allの他のPromiseは継続して処理されているため、wait2が解決されて、logBが実行されてBが出力される。
  * Promise.allのwait3が解決されて、v=0が実行される。(この時errXが実行されてcatchブロックに移動はしない？？)
  * catchブロック内のawait wait3が解決されて、2つ目のlog(v)が実行される。この時のvは0であるため、0が出力される。

# i4
## 予想
1秒後に4、さらに1秒後に3、さらに1秒後に2、さらに1秒後に1、さらに1秒後に0とCOMPLETEDが出力される。

## 結果
5秒後に0、さらに4秒後に1、さらに3秒後に2、さらに2秒後に3、さらに1秒後に4とCOMPLETEDが出力された。

## 理由
* p.then()によって、wait((5 - i) * 1000) の呼び出しをチェーンに追加しているため、追加されたthenが逐次的に呼ばれる。

# i5
## 予想
1秒後に4、さらに1秒後に3、さらに1秒後に2、さらに1秒後に1、さらに1秒後に0とCOMPLETEDが出力される。

## 結果
すぐにCOMPLETEDが出力され、さらに1秒後に4、さらに1秒後に3、さらに1秒後に2、さらに1秒後に1、さらに1秒後に0が出力された。

## 理由
* for文の中のp.then()の引数が関数ではなくPromiseになっており、引数のwait関数が設定されたタイミングで設定した時間後に順次解決するようになっている。
* また、return p.then()が呼び出される時点では、すべての waitの呼び出しがすでに始まっているため、p はすでにPromise.resolve(null)で解決済みのPromiseであるため、一番最初にlog("COMPLETED")が実行されて、COMPLETEDが出力される。

# i6
## 予想
1秒後に4、さらに1秒後に3、さらに1秒後に2、さらに1秒後に1、さらに1秒後に0とCOMPLETEDが出力される。

## 結果
1秒後に4、さらに1秒後に3、さらに1秒後に2、さらに1秒後に1、さらに1秒後に0とCOMPLETEDが出力された。

## 理由
* Promise.all()で[0,1,2,3,4]に対してwait関数の設定をし、設定したタイミングで各Promiseの待機が開始される。
* Promise.allの全てのPromiseが解決されたら、thenが実行され、COMPLETEDが出力される。

# i7
## 予想
10秒後に10が出力される。

## 結果
10秒後に10が出力された。 // 11秒後に10が出力される

## 理由
* 1秒間隔でp1とp2が交互にvを1ずつインクリメントされる。p1、p2のそれぞれfor文が終わって解決されたら、Promise.allが解決されて、log(v)で10が出力される。

# i8
## 予想
10秒後に10が出力される。

## 結果
10秒後に5が出力された。 // 9秒後に5が出力された。

## 理由
* 各ループでvの値を読み取ってから書き込む間に待機(await wait2())が入るため、その間に別の処理(p1もしくはp2)がvの値を上書きし合っているため。