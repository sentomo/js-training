{"version":3,"file":"main.js","mappings":"mBAAO,MAEMA,EAAa,GCAnB,SAASC,EAAWC,EAAMC,GAC/B,IAAK,IAAIC,EAAM,EAAGA,EDHA,GCGYA,IAC5B,IAAK,IAAIC,EAAM,EAAGA,EDHF,GCGcA,IAAO,CACnC,MAAMC,EAAOJ,EAAKE,GAAKC,GACvBF,EAAII,YACJJ,EAAIK,KAAKH,EAAML,EAAYI,EAAMJ,EAAYA,EAAYA,GACzDG,EAAIM,UAAYH,EAAO,QAAU,QACjCH,EAAIO,OACJP,EAAIQ,QACN,CAEJ,CCTA,MAAMC,EAASC,SAASC,cAAc,WAChCX,EAAMS,EAAOG,WAAW,MACxBC,EAAcH,SAASC,cAAc,UACrCG,EAAcJ,SAASC,cAAc,UAE3CF,EAAOM,MAAQC,IACfP,EAAOQ,OAASC,IAEhB,IAAIC,EAAc,KAClB,MAAMC,EAAQ,IAAIC,MAAM,iBAExB,IAAItB,EAAO,IAAIuB,MFfK,IEgBjBf,KAAK,MACLgB,KAAI,IACH,IAAID,MFjBY,IEiBAf,KAAK,MAAMgB,KAAI,MAAQC,KAAKC,MAAsB,EAAhBD,KAAKE,cAc3D,SAASC,IACP5B,EC/BK,SAAoBA,GACzB,MAAM6B,EAAW7B,EAAKwB,KAAKM,GAAQ,IAAIA,KAEvC,IAAK,IAAI5B,EAAM,EAAGA,EHLA,GGKYA,IAC5B,IAAK,IAAIC,EAAM,EAAGA,EHLF,GGKcA,IAAO,CACnC,IAAI4B,EAAgB,EACpB,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IACvB,IAAK,IAAIC,GAAK,EAAGA,GAAK,EAAGA,IAAK,CAC5B,GAAU,IAAND,GAAiB,IAANC,EAAS,SACxB,MAAMC,EAAIhC,EAAM8B,EACVG,EAAIhC,EAAM8B,EACZC,GAAK,GAAKA,EHbJ,IGagBC,GAAK,GAAKA,EHZ1B,IGYsCnC,EAAKkC,GAAGC,IACtDJ,GAEJ,CAGE/B,EAAKE,GAAKC,KAAS4B,EAAgB,GAAKA,EAAgB,GAC1DF,EAAS3B,GAAKC,IAAO,EACXH,EAAKE,GAAKC,IAA0B,IAAlB4B,IAC5BF,EAAS3B,GAAKC,IAAO,EAEzB,CAEF,OAAO0B,CACT,CDMSO,CAAWpC,GAClBD,EAAWC,EAAMC,GACjBmB,EAAciB,sBAAsBT,EACtC,CAfAlB,EAAO4B,iBAAiB,SAAS,SAAUC,GACzC,MAAMjC,EAAOI,EAAO8B,wBACdC,EAAWF,EAAIG,QAAUpC,EAAKqC,KAA9BF,EAAuCF,EAAIK,QAAUtC,EAAKuC,IAE1D3C,EAAMuB,KAAKC,MAAMe,EAAQ3C,GACzBK,EAAMsB,KAAKC,MAAMe,EAAQ3C,GAC/BE,EAAKE,GAAKC,IAAQH,EAAKE,GAAKC,GAC5BkB,EAAMyB,YAAYC,OAClBhD,EAAWC,EAAMC,EACnB,IAQAa,EAAYwB,iBAAiB,SAAS,KAChClB,GAGJQ,GAAQ,IAGVb,EAAYuB,iBAAiB,SAAS,KAC/BlB,IAGL4B,qBAAqB5B,GACrBA,EAAc,KAAI,IAGpBrB,EAAWC,EAAMC,E","sources":["webpack:///./constants.js","webpack:///./renderGrid.js","webpack:///./index.js","webpack:///./updateGrid.js"],"sourcesContent":["export const ROWS = 50;\nexport const COLS = 50;\nexport const RESOLUTION = 10;","import { ROWS, COLS, RESOLUTION } from \"./constants.js\";\n\nexport function renderGrid(grid, ctx) {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      const cell = grid[row][col];\n      ctx.beginPath();\n      ctx.rect(col * RESOLUTION, row * RESOLUTION, RESOLUTION, RESOLUTION);\n      ctx.fillStyle = cell ? \"black\" : \"white\";\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n}","import { ROWS, COLS, RESOLUTION } from \"./constants.js\";\nimport { updateGrid } from \"./updateGrid.js\";\nimport { renderGrid } from \"./renderGrid.js\";\n\nconst canvas = document.querySelector(\"#screen\");\nconst ctx = canvas.getContext(\"2d\");\nconst startButton = document.querySelector(\"#start\");\nconst pauseButton = document.querySelector(\"#pause\");\n\ncanvas.width = ROWS * RESOLUTION;\ncanvas.height = COLS * RESOLUTION;\n\nlet animationId = null;\nconst sound = new Audio(\"decision1.mp3\");\n\nlet grid = new Array(ROWS)\n  .fill(null)\n  .map(() =>\n    new Array(COLS).fill(null).map(() => !!Math.floor(Math.random() * 2))\n  );\n\ncanvas.addEventListener(\"click\", function (evt) {\n  const rect = canvas.getBoundingClientRect();\n  const pos = { x: evt.clientX - rect.left, y: evt.clientY - rect.top };\n\n  const row = Math.floor(pos.y / RESOLUTION);\n  const col = Math.floor(pos.x / RESOLUTION);\n  grid[row][col] = !grid[row][col];\n  sound.cloneNode().play();\n  renderGrid(grid, ctx);\n});\n\nfunction update() {\n  grid = updateGrid(grid);\n  renderGrid(grid, ctx);\n  animationId = requestAnimationFrame(update);\n}\n\nstartButton.addEventListener(\"click\", () => {\n  if (animationId) {\n    return;\n  }\n  update();\n});\n\npauseButton.addEventListener(\"click\", () => {\n  if (!animationId) {\n    return;\n  }\n  cancelAnimationFrame(animationId);\n  animationId = null;\n});\n\nrenderGrid(grid, ctx);\n","import { ROWS, COLS } from \"./constants.js\";\n\nexport function updateGrid(grid) {\n  const nextGrid = grid.map((arr) => [...arr]);\n\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLS; col++) {\n      let liveNeighbors = 0;\n      for (let i = -1; i <= 1; i++) {\n        for (let j = -1; j <= 1; j++) {\n          if (i === 0 && j === 0) continue;\n          const x = row + i;\n          const y = col + j;\n          if (x >= 0 && x < ROWS && y >= 0 && y < COLS && grid[x][y]) {\n            liveNeighbors++;\n          }\n        }\n      }\n\n      if (grid[row][col] && (liveNeighbors < 2 || liveNeighbors > 3)) {\n        nextGrid[row][col] = false;\n      } else if (!grid[row][col] && liveNeighbors === 3) {\n        nextGrid[row][col] = true;\n      }\n    }\n  }\n  return nextGrid;\n}"],"names":["RESOLUTION","renderGrid","grid","ctx","row","col","cell","beginPath","rect","fillStyle","fill","stroke","canvas","document","querySelector","getContext","startButton","pauseButton","width","ROWS","height","COLS","animationId","sound","Audio","Array","map","Math","floor","random","update","nextGrid","arr","liveNeighbors","i","j","x","y","updateGrid","requestAnimationFrame","addEventListener","evt","getBoundingClientRect","pos","clientX","left","clientY","top","cloneNode","play","cancelAnimationFrame"],"sourceRoot":""}